diff --git a/in/ac/iitd/src/main/java/index/bplusTree/BPlusTreeIndexFile.java b/in/ac/iitd/src/main/java/index/bplusTree/BPlusTreeIndexFile.java
index 4d23ef0..b77bf2e 100644
--- a/in/ac/iitd/src/main/java/index/bplusTree/BPlusTreeIndexFile.java
+++ b/in/ac/iitd/src/main/java/index/bplusTree/BPlusTreeIndexFile.java
@@ -3,9 +3,12 @@ package index.bplusTree;
 import storage.AbstractFile;
 
 import java.util.Queue;
-
+import java.nio.ByteBuffer; 
+import java.util.AbstractMap.SimpleEntry;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.LinkedList;
+import java.util.Map;
 
 /*
     * Tree is a collection of BlockNodes
@@ -52,13 +55,13 @@ public class BPlusTreeIndexFile<T> extends AbstractFile<BlockNode> {
     private int getRootId() {
         BlockNode node = blocks.get(0);
         byte[] rootBlockIdBytes = node.get_data(2, 2);
-        return (rootBlockIdBytes[0] << 8) | (rootBlockIdBytes[1] & 0xFF);
+        return ((rootBlockIdBytes[0] << 8) & 0xFF) | (rootBlockIdBytes[1] & 0xFF);
     }
 
     public int getOrder() {
         BlockNode node = blocks.get(0);
         byte[] orderBytes = node.get_data(0, 2);
-        return (orderBytes[0] << 8) | (orderBytes[1] & 0xFF);
+        return ((orderBytes[0] << 8) & 0xFF) | (orderBytes[1] & 0xFF);
     }
 
     private boolean isLeaf(BlockNode node){
@@ -73,14 +76,287 @@ public class BPlusTreeIndexFile<T> extends AbstractFile<BlockNode> {
     public void insert(T key, int block_id) {
 
         /* Write your code here */
+        System.out.println("\nInserting key: "+key);
+        int rootId = getRootId();
+        // int parent = -1;
+        // create a map to store parent
+        Map<Integer, Integer> parentMap = new HashMap<>(); //block id of child -> parent
+        
+        int curr = rootId;
+        // int leafId = rootId;
+        int index = -1;
+        parentMap.put(rootId, -1);
+        while(!(isLeaf(curr))){
+            //curr is internal node
+            int[] children = ((InternalNode)blocks.get(curr)).getChildren();
+            T[] keys =(T[])((InternalNode)blocks.get(curr)).getKeys();
+            for(int i=0; i<keys.length; i++){
+                if(compare(key, keys[i]) < 0 ){ // key < keys[i]
+                    index = i;
+                    break;
+                }
+                else if(compare(key, keys[i]) == 0){ // key == keys[i]
+                    index = i+1; // if multiple keys are same, go to leftmost
+                    break;
+                }
+            }
+            if(index ==-1){
+                index = children.length - 1; //right most child
+            }
+            parentMap.put(children[index], curr); 
+            curr = children[index];
+            index = -1;
+        }
+        // System.out.println("Leaf node found: "+curr);
+        // curr is leaf node -> insert in curr
+        if(!isFull(curr)){
+            // System.out.println("Leaf not full, inserting in leaf..." + "key: "+key);
+            insert_in_leaf((LeafNode)blocks.get(curr), key, block_id);
+        }
+        else{
+            LeafNode node1 = (LeafNode)blocks.get(curr); 
+            insert_in_leaf(node1, key, block_id);//node1 is overflow
+            LeafNode node2 = new LeafNode(typeClass);
+            blocks.add(node2);
+            // System.out.println("Leaf is full, splitting leaf..."+ "key: "+key);
+            split_leaf(blocks.indexOf(node1), blocks.indexOf(node2), parentMap);
+        }
         return;
     }
 
+    public void split_leaf(int id1, int id2, Map<Integer, Integer> parentMap){ //returns id of parent of node1 and node2
+        LeafNode node1 = (LeafNode)blocks.get(id1);
+        LeafNode node2 = (LeafNode)blocks.get(id2);
+        int numKeys = blocks.get(id1).getNumKeys();
+        int left = (numKeys)/2;
+        int right = numKeys - left;
+        int copyOffset = 8;
+        for(int i=0; i<left; i++){
+            byte[] lenKeyBytes = node1.get_data(copyOffset+2, 2);
+            int lenKey = (lenKeyBytes[0] << 8) | (lenKeyBytes[1] & 0xFF);
+            byte[] keyBytes = node1.get_data(copyOffset+4, lenKey);
+            copyOffset += 4 + keyBytes.length;
+        }
+        byte[] num1 = new byte[2]; 
+        // number of keys in node1 = left
+        num1[0] = (byte) (left >> 8);
+        num1[1] = (byte) (left & 0xFF);
+        node1.write_data(0, num1);
+        // nextfreeoffset in node1 = copyOffset
+        byte[] nextFreeOffsetBytes = new byte[2];
+        nextFreeOffsetBytes[0] = (byte) (copyOffset >> 8);
+        nextFreeOffsetBytes[1] = (byte) copyOffset;
+        node1.write_data(6, nextFreeOffsetBytes);
+        // number of keys in node2 = right
+        byte[] num2 = new byte[2];
+        num2[0] = (byte) (right >> 8);
+        num2[1] = (byte) (right & 0xFF) ;
+        node2.write_data(0, num2);
+        //   node2 <-- copy second half of keys of node1
+        int writeOffset = 8;
+        for(int i=0; i<right; i++){
+            byte[] blockIdBytes = node1.get_data(copyOffset, 2);
+            byte[] lenKeyBytes = node1.get_data(copyOffset+2, 2);
+            int lenKey = (lenKeyBytes[0] << 8) | (lenKeyBytes[1] & 0xFF);
+            byte[] keyBytes = node1.get_data(copyOffset+4, lenKey);
+            node2.write_data(writeOffset, blockIdBytes); //write key in node2
+            node2.write_data(writeOffset+2, lenKeyBytes);
+            node2.write_data(writeOffset+4, keyBytes);
+            
+            copyOffset += 4 + keyBytes.length;
+            writeOffset += 4 + keyBytes.length;
+        }
+        // nextfreeoffset in node2 = writeOffset
+        nextFreeOffsetBytes[0] = (byte) (writeOffset >> 8);
+        nextFreeOffsetBytes[1] = (byte) writeOffset;
+        node2.write_data(6, nextFreeOffsetBytes);
+        
+        // previous and next pointers
+        node2.write_data(4, node1.get_data(4, 2)); //next
+        byte[] id1Bytes = new byte[2];
+        id1Bytes[0] = (byte) (id1 >> 8);
+        id1Bytes[1] = (byte) id1;  
+        node2.write_data(2, id1Bytes);     //prev  
+        
+        byte[] id2Bytes = new byte[2];
+        id2Bytes[0] = (byte) (id2 >> 8);
+        id2Bytes[1] = (byte) id2;
+        node1.write_data(4, id2Bytes); //next
+        
+        // add k in parent of node1 and node2
+        byte[] lenKBytes = node2.get_data(10, 2);
+        int lenK = (lenKBytes[0] << 8) | (lenKBytes[1] & 0xFF);
+        byte[] kBytes = node2.get_data(12, lenK);
+        T k = convertBytesToT(kBytes, typeClass); //first key in node2
+
+        int parentId = parentMap.get(id1);
+        
+        InternalNode<T> parent;
+        if(parentId==-1){ //node1 is root
+            // make parent as root
+            parent = new InternalNode<>(k, id1, id2, typeClass);
+            blocks.add(parent);
+            int newRootId = blocks.indexOf(parent);
+            // update metadata block
+            BlockNode metadata =blocks.get(0);
+            byte[] newRootIdBytes = new byte[2];
+            newRootIdBytes[0] = (byte) (newRootId >> 8);
+            newRootIdBytes[1] = (byte) newRootId;
+            metadata.write_data(2, newRootIdBytes);
+        }
+        else{//node1 is not root
+            parent = (InternalNode<T>)blocks.get(parentId);
+            
+            if(!isFull(parentId)){
+                //add k in parent of node1 and node2
+                parent.insert(k, id2);
+            }
+            else{
+                //add k in parent of node1 and node2
+                parent.insert(k, id2); //overflow in parent
+                
+                // split parent
+                split_internal(parentId, parentMap);
+           }
+        }
+
+    }
+
+    public void split_internal(int nodeId1, Map<Integer, Integer> parentMap){
+        InternalNode<T> node1 = (InternalNode<T>)blocks.get(nodeId1);
+        
+        int left = (node1.getNumKeys())/2;
+        int[] children1 = node1.getChildren();
+        T[] keys1 = node1.getKeys();
+        assert(left+1<keys1.length);
+        assert(left+2<children1.length);
+        InternalNode<T> node2 = new InternalNode<>(keys1[left+1], children1[left+1], children1[left+2], typeClass); //checkkk
+        blocks.add(node2);
+        // insert keys in node2
+        System.out.println("Left:  -------------");
+        for(int i=left+2;i<keys1.length; i++){
+            node2.insert(keys1[i], children1[i+1]);
+        }
+        // delete keys from node1
+        int writeOffset = 4;
+        for(int i=0;i<left;i++){
+            byte[] lenKeyBytes = node1.get_data(writeOffset+2, 2);
+            int lenKey = (lenKeyBytes[0] << 8) | (lenKeyBytes[1] & 0xFF);
+            writeOffset += 4 + lenKey;
+        }
+        // update number of keys and nextFreeOffset in node1
+        byte[] num1 = new byte[2];
+        num1[0] = (byte) (left >> 8); num1[1] = (byte) left;
+        node1.write_data(0, num1);
+        byte[] nextFreeOffsetBytes = new byte[2];
+        nextFreeOffsetBytes[0] = (byte) (writeOffset >> 8); nextFreeOffsetBytes[1] = (byte) writeOffset;
+        node1.write_data(2, nextFreeOffsetBytes);
+
+        // add 1 key in parent of node1 
+        T shiftKey = keys1[left];
+        int nodeId2 = blocks.indexOf(node2);
+        int parentId = parentMap.get(nodeId1);
+        if(parentId ==-1){//node1 is root
+            // make parent as root
+            InternalNode<T> parent = new InternalNode<>(shiftKey, nodeId1, nodeId2 , typeClass);
+            blocks.add(parent);
+            int newRootId = blocks.indexOf(parent);
+            // update metadata block
+            BlockNode metadata = blocks.get(0);
+            byte[] newRootIdBytes = new byte[2];
+            newRootIdBytes[0] = (byte) (newRootId >> 8);
+            newRootIdBytes[1] = (byte) newRootId;
+            metadata.write_data(2, newRootIdBytes);
+        }
+        else{
+            InternalNode<T> parent = (InternalNode<T>)blocks.get(parentId);
+            if(!isFull(parentId)){
+                //add k in parent of node1 and node2
+                parent.insert(shiftKey, nodeId2);
+            }
+            else{
+                //add k in parent of node1 and node2
+                parent.insert(shiftKey, nodeId2); //overflow in parent
+                // split parent
+                split_internal(parentId, parentMap);
+            }
+           
+        }
+    }
+
+
     // will be evaluated
     // returns the block_id of the leftmost leaf node containing the key
     public int search(T key) {
-
         /* Write your code here */
+        int rootOffset = getRootId();
+        BlockNode root = blocks.get(rootOffset);
+        BlockNode curr = root ;
+        while(!(isLeaf(curr))){
+            //curr is internal node
+            int[] children = ((InternalNode<T>) curr).getChildren();
+            T[] keys = ((InternalNode<T>) curr).getKeys();
+            int index = -1;
+            for(int i=0; i<keys.length; i++){
+                if(compare( key, keys[i]) < 0 ){ // key < keys[i]
+                    index = i;
+                    break;
+                }
+                else if(compare(key, keys[i]) == 0){ // key == keys[i]
+                    index = i; // if multiple keys are same, go to leftmost
+                    break;
+                }
+            }
+            if(index ==-1){
+                index = children.length - 1; //right most child
+            }
+            curr = blocks.get(children[index]);
+        }
+        //curr is leaf node
+        
+
+        // return index(in blocks) where curr is present 
+        Boolean flag = false;
+        for(BlockNode node: blocks){
+            if(node.equals((BlockNode)curr)){
+                curr = node;
+                flag = true;
+                for(T k: ((LeafNode<T>)node).getKeys()){
+                    if(key.equals(k)){
+                        return blocks.indexOf(node);
+                    }
+                    else if(compare(key, k)<0){
+                        return blocks.indexOf(node);
+                    }
+                } 
+            }
+            // if(flag){
+            //     for(T k: ((LeafNode<T>)node).getKeys()){
+            //         if(key.equals(k)){
+            //             return blocks.indexOf(node);
+            //         }
+            //         else if(compare(key, k)<0){
+            //             return blocks.indexOf(node);
+            //         }
+            //     } 
+            // }
+        }
+        int next = ((LeafNode<T>)curr).nextLeafId();
+        while(next>0 && next < blocks.size()){
+            curr = blocks.get(next);
+            for(T k: ((LeafNode<T>)curr).getKeys()){
+                if(key.equals(k)){
+                    return blocks.indexOf(curr);
+                }
+                else if(compare(key, k)<0){
+                    return blocks.indexOf(curr);
+                }
+            }
+
+            next = ((LeafNode<T>)curr).nextLeafId();
+        } 
+
+
         return -1;
     }
 
@@ -146,4 +422,148 @@ public class BPlusTreeIndexFile<T> extends AbstractFile<BlockNode> {
         return;
     }
 
+
+    // manshi
+    public int compare(T key1, T key2){
+        // from storage file -- <T> can be: 
+        // enum ColumnType {
+        //     VARCHAR, INTEGER, BOOLEAN, FLOAT, DOUBLE
+        // };
+        /* Write your code here */
+        if(key1 instanceof String){
+            return ((String)key1).compareTo((String)key2);
+        }
+        else if(key1 instanceof Integer){
+            return ((Integer)key1).compareTo((Integer)key2);
+        }
+        else if(key1 instanceof Boolean){
+            return ((Boolean)key1).compareTo((Boolean)key2);
+        }
+        else if(key1 instanceof Float){
+            return ((Float)key1).compareTo((Float)key2);
+        }
+        else if(key1 instanceof Double){
+            return ((Double)key1).compareTo((Double)key2);
+        }
+        System.out.println("Invalid type");
+        return 0;
+    }
+    
+    public T convertBytesToT(byte[] bytes, Class<T> typeClass){
+        // from storage file -- T can be: 
+        // enum ColumnType {
+        //     VARCHAR, INTEGER, BOOLEAN, FLOAT, DOUBLE
+        // };
+        /* Write your code here */
+        if(typeClass.equals(String.class)){
+            return (T) new String(bytes);
+        }
+        else if(typeClass.equals(Integer.class)){
+            // convert to 4 byte integer
+            int value = 0;
+            for(int i=0; i<bytes.length; i++){
+                value = (value << 8) | (bytes[i] & 0xFF);
+            }
+            return (T) new Integer(value);
+        }
+        else if(typeClass.equals(Boolean.class)){
+            return (T) new Boolean(bytes[0] == 1);
+        }
+        else if(typeClass.equals(Float.class)){
+            // convert to 4 byte float
+            float floatValue = ByteBuffer.wrap(bytes).getFloat();
+            return (T) new Float(floatValue);
+        }
+        else if(typeClass.equals(Double.class)){
+            // convert to 8 byte double
+            double doubleValue = ByteBuffer.wrap(bytes).getDouble();
+            return (T) new Double(doubleValue);
+        }
+
+        System.out.println("Invalid typeClass");
+        return null;
+    }
+
+    public byte[] convertTToBytes(T key, Class<T> typeClass){
+        // from storage file -- <T> can be: 
+        // enum ColumnType {
+        //     VARCHAR, INTEGER, BOOLEAN, FLOAT, DOUBLE
+        // };
+        /* Write your code here */
+        if(typeClass.equals(String.class)){
+            return ((String)key).getBytes();
+        }
+        else if(typeClass.equals(Integer.class)){
+            int value = (Integer)key;
+            byte[] result = new byte[4];
+            for(int i=3; i>=0; i--){
+                result[i] = (byte) (value & 0xFF);
+                value = value >> 8;
+            }
+            return result;
+        }
+        else if(typeClass.equals(Boolean.class)){
+            byte[] result = new byte[1];
+            if((Boolean)key){//true
+                result[0] = 1;
+            }
+            else{
+                result[0] = 0;
+            }
+            return result;
+        }
+        else if(typeClass.equals(Float.class)){
+            float value = (Float)key;
+            return ByteBuffer.allocate(4).putFloat(value).array();
+        }
+        else if(typeClass.equals(Double.class)){
+            double value = (Double)key;
+            return ByteBuffer.allocate(8).putDouble(value).array();
+        }
+        return null;
+    }
+
+    public boolean isRoot(BlockNode node){
+        return blocks.indexOf(node) == getRootId();
+    }
+
+    public void insert_in_leaf( LeafNode node , T key, int block_id){ //node = by ref
+        node.insert(key, block_id);
+    }
+
+
+    
+public void print_tree() {
+    // print level order traversal of tree
+    int root = getRootId();
+    Queue<SimpleEntry<Integer, Integer>> queue = new LinkedList<>(); // Queue of pairs <nodeID, level>
+
+    queue.add(new SimpleEntry<>(root, 0)); // Add the root node with level 0
+    int currentLevel = 0; // Track the current level
+
+    while (!queue.isEmpty()) {
+        SimpleEntry<Integer, Integer> entry = queue.poll();
+        int id = entry.getKey();
+        int level = entry.getValue();
+
+        if (level > currentLevel) {
+            System.out.println(); // Move to the next line for a new level
+            currentLevel = level;
+        }
+
+        if (isLeaf(id)) {
+            System.out.print("("+id+":)");
+            ((LeafNode<T>) blocks.get(id)).print_node();;
+        } else {
+            System.out.print("("+id+";)");
+            ((InternalNode<T>) blocks.get(id)).print_node();;
+            int[] children = ((InternalNode<T>) blocks.get(id)).getChildren();
+            for (int i = 0; i < children.length; i++) {
+                queue.add(new SimpleEntry<>(children[i], level + 1)); // Add children nodes with increased level
+            }
+        }
+    }
+}
+
+
 }
\ No newline at end of file
diff --git a/in/ac/iitd/src/main/java/index/bplusTree/InternalNode.java b/in/ac/iitd/src/main/java/index/bplusTree/InternalNode.java
index 2217aec..84befcb 100644
--- a/in/ac/iitd/src/main/java/index/bplusTree/InternalNode.java
+++ b/in/ac/iitd/src/main/java/index/bplusTree/InternalNode.java
@@ -48,7 +48,19 @@ public class InternalNode<T> extends BlockNode implements TreeNode<T> {
         T[] keys = (T[]) new Object[numKeys];
 
         /* Write your code here */
-
+        int lenKeyOffset = 6;
+        int keyOffset = 8;
+       
+        for(int i=0; i<numKeys; i++){
+            byte[] lenKeyBytes = this.get_data(lenKeyOffset, 2);
+            int lenKey = (lenKeyBytes[0] << 8) | (lenKeyBytes[1] & 0xFF);
+
+            byte[] keyBytes = this.get_data(keyOffset, lenKey);
+            keys[i] = convertBytesToT(keyBytes, this.typeClass); // check ????????
+
+            lenKeyOffset += 2 + keyBytes.length + 2;
+            keyOffset += keyBytes.length + 2 + 2;
+        }
         return keys;
     }
 
@@ -56,6 +68,68 @@ public class InternalNode<T> extends BlockNode implements TreeNode<T> {
     @Override
     public void insert(T key, int right_block_id) {
         /* Write your code here */
+        int numKeys = this.getNumKeys();
+
+        byte[] nextFreeOffsetBytes = this.get_data(2, 2);
+        int nextFreeOffset = (nextFreeOffsetBytes[0] << 8) | (nextFreeOffsetBytes[1] & 0xFF);
+        
+        byte[] keyBytes = convertTToBytes(key, this.typeClass); 
+        int size = 2+2+ keyBytes.length;
+        // -------------------------------------------
+        // find where to insert key
+        int lenKeyOffset = 6; // len key | key | right id
+        int insertOffset = -1;
+        for(int i=0; i<numKeys; i++){
+            byte[] xlenKeyBytes = this.get_data(lenKeyOffset, 2);
+            int xlenKey = (xlenKeyBytes[0] << 8) | (xlenKeyBytes[1] & 0xFF);
+            byte[] xKeyBytes = this.get_data(lenKeyOffset+2, xlenKey);
+            T xKey = convertBytesToT(xKeyBytes, this.typeClass);
+            if(compare(key, xKey) < 0){
+                insertOffset = lenKeyOffset;
+                break;
+            }
+            lenKeyOffset += 2 + xlenKey + 2;
+        }
+        if(insertOffset==-1){
+            insertOffset = nextFreeOffset;
+        }
+        // System.out.println("Insert offset: " + insertOffset);
+        byte[] tmp = new byte[size];
+        this.write_data(nextFreeOffset, tmp); //increase size of this.data
+        // shift array 
+        for(int i= nextFreeOffset-1 ; i>=insertOffset; i--){
+            this.data[i+size] = this.data[i];
+        }
+        // System.out.println("numkeys = " + numKeys);
+        
+        // add len key, new key
+        int lenKey = keyBytes.length;
+        byte[] lenKeyBytes = new byte[2];
+        lenKeyBytes[0] = (byte) ((lenKey >> 8) & 0xFF);
+        lenKeyBytes[1] = (byte) (lenKey & 0xFF);
+        this.write_data(insertOffset, lenKeyBytes);
+        this.write_data(insertOffset+2, keyBytes);
+
+        // add right block id
+        byte[] rightBlockIdBytes = new byte[2];
+        rightBlockIdBytes[0] = (byte) ((right_block_id >> 8) & 0xFF);
+        rightBlockIdBytes[1] = (byte) (right_block_id & 0xFF);
+        this.write_data(insertOffset+2+keyBytes.length, rightBlockIdBytes);
+
+        // -------------------------------------------
+
+        // update next free offset
+        nextFreeOffset += size;
+        nextFreeOffsetBytes[0] = (byte) ((nextFreeOffset >> 8) & 0xFF);
+        nextFreeOffsetBytes[1] = (byte) (nextFreeOffset & 0xFF);
+        this.write_data(2, nextFreeOffsetBytes); 
+        
+        // update num keys
+        numKeys++;
+        byte[] numKeysBytes = new byte[2];
+        numKeysBytes[0] = (byte) ((numKeys >> 8) & 0xFF);
+        numKeysBytes[1] = (byte) (numKeys & 0xFF);
+        this.write_data(0, numKeysBytes);
 
     }
 
@@ -63,6 +137,28 @@ public class InternalNode<T> extends BlockNode implements TreeNode<T> {
     @Override
     public int search(T key) {
         /* Write your code here */
+        int numKeys = this.getNumKeys();
+        T[] keys   = this.getKeys();
+        int keyIndex = -1;
+        for(int i=0; i<keys.length; i++){
+            if(keys[i].equals(key)){
+                keyIndex = i;
+                break;
+            }
+        }
+
+        if(keyIndex==-1) return -1;
+        
+        int lenKeyOffset = 6;
+        for(int i=0; i<numKeys; i++){
+            byte[] lenKeyBytes = this.get_data(lenKeyOffset, 2);
+            int lenKey = (lenKeyBytes[0] << 8) | (lenKeyBytes[1] & 0xFF);
+
+            if(i==keyIndex){
+                return lenKeyOffset + 2;
+            }
+            lenKeyOffset += 2 + lenKey + 2;
+        }
         return -1;
     }
 
@@ -75,9 +171,41 @@ public class InternalNode<T> extends BlockNode implements TreeNode<T> {
         int[] children = new int[numKeys + 1];
 
         /* Write your code here */
-
+        int nextChildOffset = 4;
+        for(int i=0; i<numKeys+1; i++){
+            byte[] childIdBytes = this.get_data(nextChildOffset, 2);
+            children[i] = (childIdBytes[0] << 8) | (childIdBytes[1] & 0xFF);
+            
+            byte[] lenKeyBytes = this.get_data(nextChildOffset+2, 2);
+            int lenKey = (lenKeyBytes[0] << 8) | (lenKeyBytes[1] & 0xFF);
+
+            nextChildOffset += 2 + 2 + lenKey;
+        }
         return children;
+    }
+
 
+    public void print_node() {
+        // System.out.println("Internal Nodes:");
+        int numKeys = this.getNumKeys();
+        System.out.print("(" + numKeys+")" );
+        T[] keys = this.getKeys();
+        System.out.print("[");
+        for(int i=0; i<numKeys; i++){
+            System.out.print(keys[i] + " ");
+        }
+        System.out.print("] ");
+        // System.out.println();
+        // int[] children = this.getChildren();
+        // System.out.println("Children: ");
+        // for(int i=0; i<numKeys+1; i++){
+        //     System.out.print(children[i] + " ");
+        // }
+        // System.out.println();
+
+        // for(int i=4;i<30;i++){
+        //     System.out.println(this.data[i]);
+        // }
     }
 
 }
diff --git a/in/ac/iitd/src/main/java/index/bplusTree/LeafNode.java b/in/ac/iitd/src/main/java/index/bplusTree/LeafNode.java
index 2d20b35..9604dd7 100644
--- a/in/ac/iitd/src/main/java/index/bplusTree/LeafNode.java
+++ b/in/ac/iitd/src/main/java/index/bplusTree/LeafNode.java
@@ -39,19 +39,40 @@ public class LeafNode<T> extends BlockNode implements TreeNode<T>{
         T[] keys = (T[]) new Object[numKeys];
 
         /* Write your code here */
-
+        int lenKeyOffset = 10;
+        int keyOffset = 12;
+        for(int i=0;i < numKeys; i++){
+            byte[] lenKeyBytes = this.get_data(lenKeyOffset, 2);
+            int lenKey = (lenKeyBytes[0] << 8) | (lenKeyBytes[1] & 0xFF);
+
+            byte[] keyBytes = this.get_data(keyOffset, lenKey);
+            keys[i] = convertBytesToT(keyBytes, this.typeClass);
+
+            lenKeyOffset += 2 + lenKey + 2;
+            keyOffset += lenKey + 2 + 2;
+        }
         return keys;
-
     }
 
     // returns the block ids in the node - will be evaluated
     public int[] getBlockIds() {
-
         int numKeys = getNumKeys();
-
         int[] block_ids = new int[numKeys];
 
         /* Write your code here */
+        int blockIdOffset = 8;
+        int lenKeyOffset = 10;
+        for(int i=0; i<numKeys; i++){
+            byte[] blockIdBytes = this.get_data(blockIdOffset, 2);
+            int blockId = (blockIdBytes[0] << 8) | (blockIdBytes[1] & 0xFF);
+            block_ids[i] = blockId;
+
+            byte[] lenKeyByte = this.get_data(lenKeyOffset, 2);
+            int lenKey = (lenKeyByte[0] << 8) | (lenKeyByte[1] & 0xFF);
+            
+            blockIdOffset += 2 + 2 + lenKey;
+            lenKeyOffset += 2 + lenKey + 2;
+        }
 
         return block_ids;
     }
@@ -59,20 +80,134 @@ public class LeafNode<T> extends BlockNode implements TreeNode<T>{
     // can be used as helper function - won't be evaluated
     @Override
     public void insert(T key, int block_id) {
-
-
         /* Write your code here */
+        int numKeys = this.getNumKeys();
+        byte[] keyBytes = convertTToBytes(key, this.typeClass);
+        byte[] blockIdBytes = new byte[2];
+        byte[] nextFreeOffsetBytes = this.get_data(6, 2);
+        int nextFreeOffset = (nextFreeOffsetBytes[0] << 8) | (nextFreeOffsetBytes[1] & 0xFF);
+        // insert key in sorted order
+        // System.out.println("Inserting leaf key: " + key + " with block id: " + block_id);
+
+        // find where to insert key
+        int blockIdOffset = 8;
+        int insertOffset = -1;
+        for(int i=0;i<numKeys;i++){
+            byte[] xlenKeyBytes = this.get_data(blockIdOffset+2, 2);
+            int xlenKey = (xlenKeyBytes[0] << 8) | (xlenKeyBytes[1] & 0xFF);
+            byte[] xKeyBytes= this.get_data(blockIdOffset+4, xlenKey);
+            T xKey = convertBytesToT(xKeyBytes, this.typeClass);
+            if(compare(key, xKey) < 0){ //existingKey > key 
+                insertOffset = blockIdOffset;
+                break; 
+            }
+            blockIdOffset += 2 + 2 + xlenKey;
+        }
+        if(insertOffset == -1){// insert at the end
+            insertOffset = nextFreeOffset;
+        }
+        
+        // shift all values after insertOffset by size  
+        int size = 2 + 2 + keyBytes.length ;
+        byte[] tmp = new byte[size];
+        this.write_data(nextFreeOffset, tmp);
+        for(int i=nextFreeOffset-1; i>=insertOffset; i--){
+            this.data[i+size] = this.data[i];
+        }
+        blockIdBytes[0] = (byte) (block_id >> 8);
+        blockIdBytes[1] = (byte) block_id;
+
+        int lenKey = keyBytes.length;
+        byte[] lenKeyBytes = new byte[2];
+        lenKeyBytes[0] = (byte) (lenKey >> 8);
+        lenKeyBytes[1] = (byte) lenKey;
+
+        // insert blockId, lenKey, key
+        this.write_data(insertOffset, blockIdBytes);
+        this.write_data(insertOffset+2, lenKeyBytes);
+        this.write_data(insertOffset+4, keyBytes);
+
+        // update numkeys
+        numKeys++;
+        byte[] numKeysBytes = new byte[2];
+        numKeysBytes[0] = (byte) (numKeys >> 8);
+        numKeysBytes[1] = (byte) numKeys;
+        this.write_data(0, numKeysBytes);
+
+        // update next free offset
+        nextFreeOffset += size;
+        nextFreeOffsetBytes[0] = (byte) (nextFreeOffset >> 8);
+        nextFreeOffsetBytes[1] = (byte) nextFreeOffset;
+        this.write_data(6, nextFreeOffsetBytes);
 
         return;
-
     }
 
     // can be used as helper function - won't be evaluated
     @Override
     public int search(T key) {
-
         /* Write your code here */
+        int numKeys = this.getNumKeys();
+        T[] keys = this.getKeys();
+
+        int keyIndex = -1;
+        for(int i=0; i<numKeys; i++){
+            if(keys[i].equals(key)){
+                keyIndex = i;
+                break;
+            }
+        }
+
+        int blockIdOffset = 8;
+        int lenKeyOffset = 10;
+        for(int i=0; i<numKeys; i++){
+            
+            if(i==keyIndex){
+                return blockIdOffset;
+                // byte[] blockIdBytes = this.get_data(blockIdOffset, 2);
+                // int blockId = (blockIdBytes[0] << 8) | (blockIdBytes[1] & 0xFF);
+                // return blockId;
+            }
+            
+            byte[] lenKeyBytes = this.get_data(lenKeyOffset, 2);
+            int lenKey = (lenKeyBytes[0] << 8) | (lenKeyBytes[1] & 0xFF);
+            blockIdOffset += 2 + 2 + lenKey;
+            lenKeyOffset += 2 + lenKey + 2;
+
+        }
         return -1;
     }
 
-}
+
+    public void print_node() {
+        // System.out.println("Leaf Nodes:");
+        int numKeys = this.getNumKeys();
+        int id ;
+        System.out.print("(" +  numKeys + ")");
+        T[] keys = getKeys();
+        System.out.print("[");
+        for (T key : keys) {
+            System.out.print(key + " ");
+        }
+        System.out.print("] ");
+        // int numKeys = getNumKeys();
+        // int[] blockIds = getBlockIds();
+        // System.out.println("\nBlock Ids: ");
+        // for (int blockId : blockIds) {
+        //     System.out.print(blockId + " ");
+        // }
+        // System.out.println();
+
+        // for(int i=0;i<30;i++){
+        //     System.out.println(this.data[i]);
+        // }
+    }
+    public int nextLeafId(){
+        byte[] nextLeafIdBytes = this.get_data(4, 2);
+        return (nextLeafIdBytes[0] << 8) | (nextLeafIdBytes[1] & 0xFF);
+    }
+    public int prevLeafId(){
+        byte[] prevLeafIdBytes = this.get_data(2, 2);
+        return (prevLeafIdBytes[0] << 8) | (prevLeafIdBytes[1] & 0xFF);
+    }
+}
\ No newline at end of file
diff --git a/in/ac/iitd/src/main/java/index/bplusTree/TreeNode.java b/in/ac/iitd/src/main/java/index/bplusTree/TreeNode.java
index 1315e6b..bd669e6 100644
--- a/in/ac/iitd/src/main/java/index/bplusTree/TreeNode.java
+++ b/in/ac/iitd/src/main/java/index/bplusTree/TreeNode.java
@@ -1,5 +1,7 @@
 package index.bplusTree;
 
+import java.nio.ByteBuffer;
+
 // TreeNode interface - will be implemented by InternalNode and LeafNode
 public interface TreeNode <T> {
 
@@ -19,10 +21,105 @@ public interface TreeNode <T> {
     
     // Might be useful for you - will not be evaluated
     default public T convertBytesToT(byte[] bytes, Class<T> typeClass){
-        
+        // from storage file -- T can be: 
+        // enum ColumnType {
+        //     VARCHAR, INTEGER, BOOLEAN, FLOAT, DOUBLE
+        // };
         /* Write your code here */
+        if(typeClass.equals(String.class)){
+            return (T) new String(bytes);
+        }
+        else if(typeClass.equals(Integer.class)){
+            // convert to 4 byte integer
+            int value = 0;
+            for(int i=0; i<bytes.length; i++){
+                value = (value << 8) | (bytes[i] & 0xFF);
+            }
+            return (T) new Integer(value);
+        }
+        else if(typeClass.equals(Boolean.class)){
+            return (T) new Boolean(bytes[0] == 1);
+        }
+        else if(typeClass.equals(Float.class)){
+            // convert to 4 byte float
+            float floatValue = ByteBuffer.wrap(bytes).getFloat();
+            return (T) new Float(floatValue);
+        }
+        else if(typeClass.equals(Double.class)){
+            // convert to 8 byte double
+            double doubleValue = ByteBuffer.wrap(bytes).getDouble();
+            return (T) new Double(doubleValue);
+        }
 
+        System.out.println("Invalid typeClass");
+        return null;
+    }
+    
+
+    // manshi
+    default public byte[] convertTToBytes(T key, Class<T> typeClass){
+        // from storage file -- <T> can be: 
+        // enum ColumnType {
+        //     VARCHAR, INTEGER, BOOLEAN, FLOAT, DOUBLE
+        // };
+        /* Write your code here */
+        if(typeClass.equals(String.class)){
+            return ((String)key).getBytes();
+        }
+        else if(typeClass.equals(Integer.class)){
+            int value = (Integer)key;
+            byte[] result = new byte[4];
+            for(int i=3; i>=0; i--){
+                result[i] = (byte) (value & 0xFF);
+                value = value >> 8;
+            }
+            return result;
+        }
+        else if(typeClass.equals(Boolean.class)){
+            byte[] result = new byte[1];
+            if((Boolean)key){//true
+                result[0] = 1;
+            }
+            else{
+                result[0] = 0;
+            }
+            return result;
+        }
+        else if(typeClass.equals(Float.class)){
+            float value = (Float)key;
+            return ByteBuffer.allocate(4).putFloat(value).array();
+        }
+        else if(typeClass.equals(Double.class)){
+            double value = (Double)key;
+            return ByteBuffer.allocate(8).putDouble(value).array();
+        }
         return null;
     }
+
     
+    default public int compare(T key1, T key2){
+        // from storage file -- <T> can be: 
+        // enum ColumnType {
+        //     VARCHAR, INTEGER, BOOLEAN, FLOAT, DOUBLE
+        // };
+        /* Write your code here */
+        if(key1 instanceof String){
+            return ((String)key1).compareTo((String)key2);
+        }
+        else if(key1 instanceof Integer){
+            return ((Integer)key1).compareTo((Integer)key2);
+        }
+        else if(key1 instanceof Boolean){
+            return ((Boolean)key1).compareTo((Boolean)key2);
+        }
+        else if(key1 instanceof Float){
+            return ((Float)key1).compareTo((Float)key2);
+        }
+        else if(key1 instanceof Double){
+            return ((Double)key1).compareTo((Double)key2);
+        }
+        System.out.println("Invalid type");
+        return 0;
+    }
+ 
 }
\ No newline at end of file
diff --git a/in/ac/iitd/src/main/java/manager/StorageManager.java b/in/ac/iitd/src/main/java/manager/StorageManager.java
index c1eb28a..0542ac4 100644
--- a/in/ac/iitd/src/main/java/manager/StorageManager.java
+++ b/in/ac/iitd/src/main/java/manager/StorageManager.java
@@ -2,16 +2,20 @@ package manager;
 
 import storage.DB;
 import storage.File;
+import storage.AbstractFile;
 import storage.Block;
 import Utils.CsvRowConverter;
+import index.bplusTree.BPlusTreeIndexFile;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
+import java.nio.ByteBuffer;
 import java.util.HashMap;
 import java.util.List;
 import java.util.ArrayList;
 
+// import org.apache.calcite.adapter.clone.ArrayTable.Column;
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexLiteral;
 import org.apache.calcite.util.Sources;
@@ -20,6 +24,7 @@ import org.json.simple.JSONArray;
 import org.json.simple.JSONObject;
 import org.json.simple.parser.JSONParser;
 import org.json.simple.parser.ParseException;
+import org.omg.PortableInterceptor.INACTIVE;
 
 import java.util.Iterator;
 
@@ -384,26 +389,276 @@ public class StorageManager {
     // the order of returned columns should be same as the order in schema
     // i.e., first all fixed length columns, then all variable length columns
     public List<Object[]> get_records_from_block(String table_name, int block_id){
+        System.out.println("get_records_from_block.........");
+        System.out.println("table_name: " + table_name + " block_id: " + block_id);
         /* Write your code here */
         // return null if file does not exist, or block_id is invalid
+        if(!check_file_exists(table_name)){
+            return null;
+        }
+        int file_id = file_to_fileid.get(table_name);
+        byte[] block = db.get_data(file_id, block_id);
+        
+        if(block == null){
+            return null;
+        }
         // return list of records otherwise
-        return null;
+        // block -> records(rows of csv) -> fields(columns of csv)
+        // list -> of records
+        // object[] -> of fields in a record
+        List<Object[]> allRecords = new ArrayList<>();
+        List<byte[]> allRecordsBytes = new ArrayList<>();
+        // first 2 bytes are for number of records in that block
+        int numRecords = (block[1] & 0xFF) | (block[0]<<8); // big endian
+        System.out.println("numRecords: " + numRecords);
+        int offset = 2;
+        for(int i=0; i<numRecords; i++){
+            byte[] recordBytes;
+            if(i==0){
+                byte[] recordOffsetBytes = new byte[2];
+                recordOffsetBytes[0] = block[offset];
+                recordOffsetBytes[1] = block[offset+1];
+                int recordOffset = (recordOffsetBytes[1]  & 0xFF) | (recordOffsetBytes[0] << 8);
+                recordBytes = new byte[4096-recordOffset];
+                for(int k=0;k<4096-recordOffset;k++){
+                    recordBytes[k] = block[recordOffset+k];
+                }
+
+            }
+            else{
+                byte[] prevOffsetBytes = new byte[2];
+                prevOffsetBytes[0] = block[offset-2];
+                prevOffsetBytes[1] = block[offset-1];
+                byte[] recordOffsetBytes = new byte[2];
+                recordOffsetBytes[0] = block[offset];
+                recordOffsetBytes[1] = block[offset+1];
+                int prevOffset = (prevOffsetBytes[1]  & 0xFF) | (prevOffsetBytes[0] <<8);
+                int recordOffset = (recordOffsetBytes[1] & 0xFF) | (recordOffsetBytes[0] << 8);
+                recordBytes = new byte[prevOffset - recordOffset];
+                for(int j=0;j<prevOffset - recordOffset;j++){
+                    recordBytes[j] = block[recordOffset+j];
+                }                
+            }
+            offset += 2;
+            allRecordsBytes.add(recordBytes);
+        }
+        // map to store(columnNumber, columnType)
+        HashMap<Integer, ColumnType> columnTypeMap = new HashMap<>();
+        // read metadata block to get column types
+        byte[] metadataBlock = db.get_data(file_id, 0);
+        int numColumns = (metadataBlock[0] & 0xFF) | (metadataBlock[1] << 8); // little endian
+        for(int i=2;i<= numColumns*2 ;i+=2){
+            int colOffset = (metadataBlock[i] & 0xFF) | (metadataBlock[i+1] << 8); // little endian
+            if(colOffset == 0){
+                break;
+            }
+            byte colType = metadataBlock[colOffset];
+            columnTypeMap.put(i/2 - 1, ColumnType.values()[colType]);
+        }
+
+        int varLenFields = 0;
+        for(int i=0;i<numColumns;i++){
+            if(columnTypeMap.get(i) == ColumnType.VARCHAR){
+                varLenFields++;
+            }
+        }
+        System.out.println("varLenFields: " + varLenFields);
+        // convert each byte[] to object[]
+        for(int i=0; i<numRecords; i++){
+            // System.out.println("i th record============================= " + i);
+            byte[] recordBytes = allRecordsBytes.get(i);
+            Object[] record = new Object[numColumns];
+            int offsetf = 0;
+            //read fixed length fields
+            for(int j= 0; j<numColumns - varLenFields; j++){
+                int offsetj = 4*varLenFields  + offsetf;
+                if(columnTypeMap.get(j)== ColumnType.INTEGER ){
+                    // System.out.println("int");
+                    byte[] fieldBytes = new byte[4];
+                    for(int k=0;k<4;k++){
+                        fieldBytes[k] = recordBytes[offsetj+k];
+                    }
+                    record[j] = convertBytesToObject(fieldBytes, Integer.class);
+                    offsetf += 4;
+                }
+                else if(columnTypeMap.get(j)== ColumnType.BOOLEAN ){
+                    // System.err.println("bool");
+                    byte[] fieldBytes = new byte[1];
+                    for(int k=0;k<1;k++){
+                        fieldBytes[k] = recordBytes[offsetj+k];
+                    }
+                    record[j] = convertBytesToObject(fieldBytes, Boolean.class);
+                    offsetf += 1;
+                }
+                else if(columnTypeMap.get(j)== ColumnType.FLOAT ){
+                    // System.out.println("float");
+                    byte[] fieldBytes = new byte[4];
+                    for(int k=0;k<4;k++){
+                        fieldBytes[k] = recordBytes[offsetj+k];
+                    }
+                    record[j] = convertBytesToObject(fieldBytes, Float.class);
+                    offsetf += 4;
+                }
+                else if(columnTypeMap.get(j)== ColumnType.DOUBLE ){
+                    // System.out.println("double");
+                    byte[] fieldBytes = new byte[8];
+                    for(int k=0;k<8;k++){
+                        fieldBytes[k] = recordBytes[offsetj+k];
+                    }
+                    record[j] = convertBytesToObject(fieldBytes, Double.class);
+                    offsetf += 8;
+                }
+            }
+            
+            //read variable length fields
+            for(int j=0;j<varLenFields; j++){
+                // System.out.println("varchar");
+                int offsetj = (recordBytes[j*4+1] << 8) | (recordBytes[j*4] & 0xFF); 
+                int lengthj = (recordBytes[j*4+3] << 8) | (recordBytes[j*4+2] & 0xFF); 
+                // System.out.println("offsetj: " + offsetj + " lengthj: " + lengthj);
+                byte[] fieldBytes = new byte[lengthj];
+                for(int k=0;k<lengthj;k++){
+                    fieldBytes[k] = recordBytes[offsetj+k];
+                }
+                // convert fieldBytes to varchar object
+                record[j + (numColumns - varLenFields)] = convertBytesToObject(fieldBytes, String.class);
+            }
+            // null bit map
+            int tmp = 4*varLenFields;
+            // traverse in columntypemap
+            for(int j=0;j<numColumns;j++){
+                // if integer type add 4 in tmp
+                if(columnTypeMap.get(j) == ColumnType.INTEGER){
+                    tmp += 4;
+                }
+                else if(columnTypeMap.get(j) == ColumnType.BOOLEAN){
+                    tmp += 1;
+                }
+                else if(columnTypeMap.get(j) == ColumnType.FLOAT){
+                    tmp += 4;
+                }
+                else if(columnTypeMap.get(j) == ColumnType.DOUBLE){
+                    tmp += 8;
+                }
+            }
+            byte[] nullBitmap = new byte[(numColumns + 7) / 8];
+            for(int j=0;j<(numColumns + 7) / 8;j++){
+                nullBitmap[j] = recordBytes[tmp+j];
+            }
+            // read bitmap
+            for(int x=0; x<numColumns; x++){
+                // read ith bit
+                int byteIndex = x / 8;
+                int bitIndex = x % 8;
+                if((nullBitmap[byteIndex] & (1 << (7 - bitIndex))) != 0){
+                    record[x] = null;
+                }
+            }
+            allRecords.add(record);
+        }
+        System.out.println("get records from block complete--- " + allRecords.size());
+        return allRecords;
+        // return null;
     }
 
     public boolean create_index(String table_name, String column_name, int order) {
         /* Write your code here */
-        return false;
+        int file_id = file_to_fileid.get(table_name);
+        System.out.println("file_id: " + file_id);
+        if(file_id == -1){
+            System.out.println("File not found in database");
+            return false;
+        }
+        // create index file
+        
+        // get columnID from column_name using metadata block
+        int columnID = -1;
+        byte[] metadataBlock = db.get_data(file_id, 0);
+        int numColumns = (metadataBlock[0] & 0xFF) | (metadataBlock[1] << 8); // little endian
+        // System.out.println("numColumns: " + numColumns);
+        // read metadata
+        byte columnTypeByte = 0;
+        Object typeObj = null ;
+        for(int i=2;i< numColumns*2 ;i+=2){
+            int colOffset = (metadataBlock[i] & 0xFF) | (metadataBlock[i+1] << 8); // little endian
+            System.out.println("colOffset: " + colOffset);
+            int colNameLength = metadataBlock[colOffset+1];
+            System.out.println("colNameLength: " + colNameLength);
+            byte[] colNameBytes = new byte[colNameLength];
+            for(int j=0;j<colNameLength;j++){
+                colNameBytes[j] = metadataBlock[colOffset+2+j];
+            }
+            String colName = new String(colNameBytes);
+            System.out.println("colName: " + colName + "colid = " + (i/2-1)); ;
+            if(colName.equals(column_name)){
+                columnID = i/2 - 1;
+                columnTypeByte = metadataBlock[colOffset];
+                typeObj = getColumnType(columnTypeByte);
+                // columnType = ColumnType.values()[colType];
+                break;
+            }
+        }
+        // System.out.println("columnID: " + columnID);
+        if(columnID == -1){
+            System.out.println("Column not found in metadata block");
+            return false;
+        }
+        // create tree = index file
+        
+        //enum ????????? columntype
+        BPlusTreeIndexFile<Object> indexTree = new BPlusTreeIndexFile(order, typeObj.getClass());
+        int counter = db.addFile(indexTree);
+        file_to_fileid.put(table_name + "_" + column_name + "_index", counter);
+
+        // int numBlocks ;
+        // if(db.get_num_records(file_id) % 4096 == 0){
+        //     numBlocks = db.get_num_records(file_id) / 4096;
+        // }
+        // else{
+        //     numBlocks = db.get_num_records(file_id) / 4096 + 1;
+        // }
+
+        // System.out.println("numBlocks: " + numBlocks);
+
+        // for(int i=1; i<=numBlocks; i++){
+        int b=1;
+        while(get_records_from_block(table_name, b)!= null){
+            List<Object[]> records = get_records_from_block(table_name, b);
+            System.out.println("records_size: " + records.size());
+            for(int j=0; j<(int)records.size(); j++){
+                Object[] record = records.get(j);
+                Object key = record[columnID];
+                indexTree.insert((Integer)key, b);
+            }
+            b++;
+        }
+        // print tree 
+        indexTree.print_tree();
+        System.out.println("create index done...");
+        return true;
     }
 
     // returns the block_id of the leaf node where the key is present
     public int search(String table_name, String column_name, RexLiteral value) {
         /* Write your code here */
-        return -1;
+        System.out.println("search..." + value);
+        int file_id = file_to_fileid.get(table_name + "_" + column_name + "_index");
+        if(file_id == -1){
+            System.out.println("Index file not found");
+            return -1;
+        }
+        System.out.println("file_id: " + file_id);
+        int val = value.getValueAs(Integer.class);
+        System.out.println("val: " + val);
+        int block_id = db.search_index(file_id, val);
+        System.out.println("block_id of leaf ( leafid ): " + block_id);
+        return block_id;
     }
 
     public boolean delete(String table_name, String column_name, RexLiteral value) {
         /* Write your code here */
         // Hint: You need to delete from both - the file and the index
+
         return false;
     }
 
@@ -422,4 +677,51 @@ public class StorageManager {
         return null;
     }
 
-}
\ No newline at end of file
+    // manshi
+    public int getFileId(String table_name){
+        return file_to_fileid.get(table_name);
+    }
+    public Object convertBytesToObject(byte[] bytes, Class<?> typeClass){
+        if(typeClass.equals(String.class)){
+            return new String(bytes);
+        }
+        else if(typeClass.equals(Integer.class)){
+            int value = 0;
+            for(int i=3; i>=0; i--){
+                value = (value << 8) | (bytes[i] & 0xFF);
+            }
+            return new Integer(value);
+        }
+        else if(typeClass.equals(Boolean.class)){
+            return new Boolean(bytes[0] == 1);
+        }
+        else if(typeClass.equals(Float.class)){
+            float floatValue = ByteBuffer.wrap(bytes).getFloat();
+            return new Float(floatValue);
+        }
+        else if(typeClass.equals(Double.class)){
+            double doubleValue = ByteBuffer.wrap(bytes).getDouble();
+            return new Double(doubleValue);
+        }
+
+        System.out.println("Invalid typeClass");
+        return null;
+    }
+    Object getColumnType(byte dataTypeByte) {
+        switch (dataTypeByte) {
+            case 0: // Assuming 0 represents VARCHAR
+                return new String();
+            case 1: // Assuming 1 represents INTEGER
+                return new Integer(0);
+            case 2: // Assuming 2 represents BOOLEAN
+                return new Boolean(false);
+            case 3: // Assuming 3 represents FLOAT
+                return new Float(0);
+            case 4: // Assuming 4 represents DOUBLE
+                return new Double(0);
+            default:
+                throw new IllegalArgumentException("Invalid byte value for datatype");
+        }
+    }
+
+}
diff --git a/in/ac/iitd/src/main/java/optimizer/rel/PIndexScan.java b/in/ac/iitd/src/main/java/optimizer/rel/PIndexScan.java
index db265b7..3efd449 100644
--- a/in/ac/iitd/src/main/java/optimizer/rel/PIndexScan.java
+++ b/in/ac/iitd/src/main/java/optimizer/rel/PIndexScan.java
@@ -6,11 +6,20 @@ import org.apache.calcite.plan.RelTraitSet;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.TableScan;
 import org.apache.calcite.rel.type.RelDataType;
+import org.apache.calcite.rex.RexCall;
+import org.apache.calcite.rex.RexLiteral;
 import org.apache.calcite.rex.RexNode;
 
+import index.bplusTree.BPlusTreeIndexFile;
 import manager.StorageManager;
 
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
 import java.util.List;
+import java.util.regex.*;
+import java.util.Set;
+import java.util.HashSet;
+
 
 // Operator trigged when doing indexed scan
 // Matches SFW queries with indexed columns in the WHERE clause
@@ -54,7 +63,336 @@ public class PIndexScan extends TableScan implements PRel {
             System.out.println("Evaluating PIndexScan for table: " + tableName);
 
             /* Write your code here */
+            List<Object[]> result = new ArrayList<>();
+            // DB db = storage_manager.getDB();
+            if(!storage_manager.check_file_exists(tableName)){
+                System.out.println("Table does not exist");
+                return null;
+
+            }
+            System.out.println("rowtype: " + rowType);
+            System.out.println("filter: " + filter);
+
+            String opString = ((RexCall) filter).getOperator().getName();
+            System.out.println("opString: " + opString);
+            String s = ((RexCall)filter).getOperands().get(0).toString();
+            // 
+            String temp = s.substring(1);
+            // System.out.println("s: " + temp);
+
+            int column = Integer.parseInt(temp);
+            System.out.println("column: " + column);
+            RexCall op = (RexCall) filter;
+            RexLiteral rexValue = (RexLiteral) op.getOperands().get(1);
+            System.out.println("rexvalue: " + rexValue.getValue());
+            
+
+            String colName = rowType.getFieldList().get(column).getName();
+            System.out.println("colName: " + colName);
+
+            String indexFile = tableName + "_" + colName + "_index";
+            if(!storage_manager.check_file_exists(indexFile)){
+                System.out.println("Index file does not exist");
+                return null;
+            }
+            
+            byte[] metadataBlock = storage_manager.get_data_block(tableName, 0);
+            int colOffset = (metadataBlock[2*(column+1)] & 0xFF) | (metadataBlock[1 + 2*(column+1)] << 8); // little endian
+            byte columnTypeByte = metadataBlock[colOffset];
+            Object typeObj = getColumnType(columnTypeByte);
+
+            Set<Integer> blockIdsSet = new HashSet<>();
+            if(opString.contains("=")){
+                int node_id = storage_manager.search(tableName, colName, rexValue);
+                System.out.println("node_id: " + node_id);
+                System.out.println("EQUALS");
+                if(node_id == -1){
+                    System.out.println("Value not found");
+                    return null;
+                }
+                
+                byte[] nodeData = storage_manager.get_data_block(indexFile, node_id);
+                System.out.println("nodeData: " + nodeData);
+                Object[] keys = getKeys(nodeData, typeObj.getClass());
+                
+                int[] blockIds = getBlockIds(nodeData);
+                System.out.println("keys length: " + keys.length);
+                System.out.println("blockids length: " + blockIds.length);
+                
+                while (node_id!=0) {
+                    System.out.println("node_id: " + node_id);
+                    for( int i=0; i<keys.length; i++){
+                        System.out.println("keys[i]: " + keys[i]);
+                        if( compare(keys[i], rexValue.getValue(), typeObj) == 0){
+                            blockIdsSet.add(blockIds[i]);
+                            // blockIdsSet.add(blockIds[i+1]);
+                        }
+                    }
+                    node_id = nextLeafId(nodeData);
+                    System.out.println("next node_id: " + node_id);
+                    nodeData = storage_manager.get_data_block(indexFile, node_id);
+                    keys = getKeys(nodeData, typeObj.getClass());
+                    blockIds = getBlockIds(nodeData);
+                }
+            }
+
+            if(opString.contains("<")){
+                int node_id = storage_manager.search(tableName, colName, rexValue);
+                System.out.println("LESS THAN");
+                if(node_id == -1){
+                    System.out.println("Value not found");
+                    return null;
+                }
+                byte[] nodeData = storage_manager.get_data_block(indexFile, node_id);
+                Object[] keys = getKeys(nodeData, typeObj.getClass());
+                int[] blockIds = getBlockIds(nodeData);
+
+                while (node_id!=0) {
+                    for( int i=0; i<keys.length; i++){
+                        if( compare(keys[i], rexValue.getValue(), typeObj) < 0){
+                            blockIdsSet.add(blockIds[i]);
+                            // blockIdsSet.add(blockIds[i+1]);
+                        }
+                    }
+                    node_id = prevLeafId(node_id, indexFile, storage_manager);
+                    nodeData = storage_manager.get_data_block(indexFile, node_id);
+                    keys = getKeys(nodeData, typeObj.getClass());
+                    blockIds = getBlockIds(nodeData);
+                }
+
+            }
+            else if(opString.contains(">")){
+                int node_id = storage_manager.search(tableName, colName, rexValue);
+                System.out.println("GREATER THAN");
+                if(node_id == -1){
+                    System.out.println("Value not found");
+                    return null;
+                }
+                byte[] nodeData = storage_manager.get_data_block(indexFile, node_id);
+                Object[] keys = getKeys(nodeData, typeObj.getClass());
+                int[] blockIds = getBlockIds(nodeData);
+
+                while (node_id!=0) {
+                    for( int i=0; i<keys.length; i++){
+                        if( compare(keys[i], rexValue.getValue(), typeObj) > 0){
+                            blockIdsSet.add(blockIds[i]);
+                            // blockIdsSet.add(blockIds[i+1]);
+                        }
+                    }
+                    node_id = nextLeafId(nodeData);
+                    nodeData = storage_manager.get_data_block(indexFile, node_id);
+                    keys = getKeys(nodeData, typeObj.getClass());
+                    blockIds = getBlockIds(nodeData);
+                }
+
+            }
+            // ---------now we have blockids that we need to scan
+            for(Integer blockid : blockIdsSet){
+                List<Object[]> records = storage_manager.get_records_from_block(tableName, blockid);
+                for(Object[] record : records){
+                    if(opString.contains(opString)){
+                        if(compare(record[column], rexValue.getValue(), typeObj) == 0){
+                            result.add(record);
+                        }
+                    }
+                    if(opString.contains("<")){
+                        if(compare(record[column], rexValue.getValue(), typeObj) < 0){
+                            result.add(record);
+                        }
+                    }
+                    else if(opString.contains(">")){
+                        if(compare(record[column], rexValue.getValue(), typeObj) > 0){
+                            result.add(record);
+                        }
+                    }
+                }
+            }
+            return result;
+        }
+        // manshi----------------------------------------------------------------------------------------------------------------------------------
+        Object getColumnType(byte dataTypeByte) {
+            switch (dataTypeByte) {
+                case 0: // Assuming 0 represents VARCHAR
+                    return new String();
+                case 1: // Assuming 1 represents INTEGER
+                    return new Integer(0);
+                case 2: // Assuming 2 represents BOOLEAN
+                    return new Boolean(false);
+                case 3: // Assuming 3 represents FLOAT
+                    return new Float(0);
+                case 4: // Assuming 4 represents DOUBLE
+                    return new Double(0);
+                default:
+                    throw new IllegalArgumentException("Invalid byte value for datatype");
+            }
+        }
+        
+        Object[] getKeys(byte[] leafData, Class<?> typeClass) {
+            int numKeys = getNumKeys(leafData);
+            // System.out.println("numKeys: " + numKeys);
+            Object[] keys = new Object[numKeys];
+            /* Write your code here */
+            int lenKeyOffset = 10;
+            int keyOffset = 12;
+            for(int i=0;i < numKeys; i++){
+                byte[] lenKeyBytes = get_data(leafData, lenKeyOffset, 2);
+                int lenKey = (lenKeyBytes[0] << 8) | (lenKeyBytes[1] & 0xFF);
+    
+                byte[] keyBytes = get_data(leafData, keyOffset, lenKey);
+                for(int b: keyBytes){
+                    System.out.print(b + ", ");
+                }
+                keys[i] = convertBytesToObject(keyBytes,typeClass);
+    
+                lenKeyOffset += 2 + lenKey + 2;
+                keyOffset += lenKey + 2 + 2;
+            }
+            return keys;
+        }
+    
+        int[] getBlockIds(byte[] leafData) {
+            int numKeys = getNumKeys(leafData);
+            int[] block_ids = new int[numKeys];
+    
+            /* Write your code here */
+            int blockIdOffset = 8;
+            int lenKeyOffset = 10;
+            for(int i=0; i<numKeys; i++){
+                byte[] blockIdBytes = get_data(leafData, blockIdOffset, 2);
+                int blockId = (blockIdBytes[0] << 8) | (blockIdBytes[1] & 0xFF);
+                block_ids[i] = blockId;
+    
+                byte[] lenKeyByte = get_data(leafData, lenKeyOffset, 2);
+                int lenKey = (lenKeyByte[0] << 8) | (lenKeyByte[1] & 0xFF);
+                
+                blockIdOffset += 2 + 2 + lenKey;
+                lenKeyOffset += 2 + lenKey + 2;
+            }
+    
+            return block_ids;
+        }
+        
+        public int getNumKeys(byte[] data) {
+            byte[] numKeysBytes = get_data(data, 0, 2);
+            return (numKeysBytes[0] << 8) | (numKeysBytes[1] & 0xFF);
+        }
+        
+        public byte[] get_data(byte[] data, int offset, int length) {
+            if(offset + length > data.length){
+                return null;
+            }
+            byte[] result = new byte[length];
+            System.arraycopy(data, offset, result, 0, length);
+            return result;
+        }
+        
+        public Object convertBytesToObject(byte[] bytes, Class<?> typeClass){
+            // if(typeClass.equals(String.class)){
+            //     return new String(bytes);
+            // }
+            // else if(typeClass.equals(Integer.class)){
+            //     int value = 0;
+            //     for(int i=0; i<4; i++){
+            //         value = (value << 8) | (bytes[i] & 0xFF);
+            //     }
+            //     return new Integer(value);
+            // }
+            // else if(typeClass.equals(Boolean.class)){
+            //     return new Boolean(bytes[0] == 1);
+            // }
+            // else if(typeClass.equals(Float.class)){
+            //     float floatValue = ByteBuffer.wrap(bytes).getFloat();
+            //     return new Float(floatValue);
+            // }
+            // else if(typeClass.equals(Double.class)){
+            //     double doubleValue = ByteBuffer.wrap(bytes).getDouble();
+            //     return new Double(doubleValue);
+            // }
+            if(typeClass.equals(String.class)){
+                return new String(bytes);
+            }
+            else if(typeClass.equals(Integer.class)){
+                // convert to 4 byte integer
+                int value = 0;
+                for(int i=0; i<bytes.length; i++){
+                    value = (value << 8) | (bytes[i] & 0xFF);
+                }
+                return new Integer(value);
+            }
+            else if(typeClass.equals(Boolean.class)){
+                return new Boolean(bytes[0] == 1);
+            }
+            else if(typeClass.equals(Float.class)){
+                // convert to 4 byte float
+                float floatValue = ByteBuffer.wrap(bytes).getFloat();
+                return new Float(floatValue);
+            }
+            else if(typeClass.equals(Double.class)){
+                // convert to 8 byte double
+                double doubleValue = ByteBuffer.wrap(bytes).getDouble();
+                return new Double(doubleValue);
+            }
 
+            System.out.println("Invalid typeClass");
             return null;
         }
+        
+        String[] extractStrings(String s2) {
+            String regex = "^(.*?)\\(\\$([a-zA-Z0-9]+),\\s*([a-zA-Z0-9]+)\\)$";
+            Pattern pattern = Pattern.compile(regex);
+            Matcher matcher = pattern.matcher(s2);
+            if (matcher.find()) {
+                String s1 = matcher.group(1);
+                String val1 = matcher.group(2);
+                String val2 = matcher.group(3);
+                return new String[]{s1, val1, val2};
+            } else {
+                // Return an empty array or handle the case where no match is found
+                return new String[]{"", "", ""};
+            }
+        }
+        
+        public int nextLeafId(byte[] nodeData){
+            // byte[] nodeData = storage_manager.get_data_block(tableName, node_id);
+            byte[] nextLeafIdBytes = get_data(nodeData , 4, 2);
+            return (nextLeafIdBytes[0] << 8) | (nextLeafIdBytes[1] & 0xFF);
+        }
+        
+        public int prevLeafId( int node_id, String tableName, StorageManager storage_manager){
+            byte[] nodeData = storage_manager.get_data_block(tableName, node_id);
+            byte[] prevLeafIdBytes = get_data(nodeData, 2, 2);
+            return (prevLeafIdBytes[0] << 8) | (prevLeafIdBytes[1] & 0xFF);
+        }
+
+        int compare(Object obj1, Object obj2, Object typeObj){
+            if(typeObj instanceof String){
+                String s2 =obj2.toString();
+                return ((String)obj1).compareTo(s2);
+            }
+            else if(typeObj instanceof Integer){
+                String s2 = obj2.toString();
+                int obj2Int = Integer.parseInt(s2);
+
+                return Integer.compare((Integer)obj1, obj2Int);
+            }
+            else if(typeObj instanceof Boolean){
+                String s2 = obj2.toString();
+                Boolean obj2Bool = Boolean.parseBoolean(s2);
+                return Boolean.compare((Boolean)obj1, obj2Bool) ;
+            }
+            else if(typeObj instanceof Float){
+                String s2 = obj2.toString();
+                Float obj2Float = Float.parseFloat(s2);
+                return Float.compare((Float)obj1, obj2Float) ;
+            }
+            else if(typeObj instanceof Double){
+                String s2 = obj2.toString();
+                Double obj2Double = Double.parseDouble(s2);
+                return Double.compare((Double)obj1, obj2Double) ;
+            }
+            return 0;
+        }
+
+
+       
 }
\ No newline at end of file
diff --git a/in/ac/iitd/src/main/java/storage/DB.java b/in/ac/iitd/src/main/java/storage/DB.java
index b6041f6..2046c84 100644
--- a/in/ac/iitd/src/main/java/storage/DB.java
+++ b/in/ac/iitd/src/main/java/storage/DB.java
@@ -23,7 +23,7 @@ public class DB {
         files.add(file);
         return files.size() - 1;
 
-    }
+    } 
     
     public byte[] get_data(int file_id, int block_id, int offset, int length){
         if(file_id >= files.size()){
diff --git a/in/ac/iitd/src/test/java/MyCalciteConnectionTest.java b/in/ac/iitd/src/test/java/MyCalciteConnectionTest.java
index b0ea88e..fcbee13 100644
--- a/in/ac/iitd/src/test/java/MyCalciteConnectionTest.java
+++ b/in/ac/iitd/src/test/java/MyCalciteConnectionTest.java
@@ -51,24 +51,24 @@ public class MyCalciteConnectionTest {
 
             // Uncomment this to check the records returned by IndexScan
             
-            // assert (result.size() == 101);
+            assert (result.size() == 101);
 
-            // List <Integer> actor_ids = new ArrayList<>();
+            List <Integer> actor_ids = new ArrayList<>();
 
-            // for (Object [] row : result) {
-            //     assert (row.length == 4);
-            //     assert (row[0] instanceof Integer);
-            //     assert ((Integer)row[0] >= 100);
-            //     actor_ids.add((Integer)row[0]);
-            // }
+            for (Object [] row : result) {
+                assert (row.length == 4);
+                assert (row[0] instanceof Integer);
+                assert ((Integer)row[0] >= 100);
+                actor_ids.add((Integer)row[0]);
+            }
 
-            // // sort the actor_ids
-            // actor_ids.sort(null);
+            // sort the actor_ids
+            actor_ids.sort(null);
 
-            // // result actor_ids should be from 100 to 200
-            // for (int i = 0; i < actor_ids.size(); i++) {
-            //     assert (actor_ids.get(i).equals(100 + i));
-            // }
+            // result actor_ids should be from 100 to 200
+            for (int i = 0; i < actor_ids.size(); i++) {
+                assert (actor_ids.get(i).equals(100 + i));
+            }
 
             calciteConnection.close();
         }
diff --git a/in/ac/iitd/src/test/java/manager/BPlusTreeTest.java b/in/ac/iitd/src/test/java/manager/BPlusTreeTest.java
index 47cd5e5..ad6c3fe 100644
--- a/in/ac/iitd/src/test/java/manager/BPlusTreeTest.java
+++ b/in/ac/iitd/src/test/java/manager/BPlusTreeTest.java
@@ -35,10 +35,10 @@ public class BPlusTreeTest {
             // 5 9 3 7 11 13 2 4 6 8 10 12 14 15 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
 
             // Uncomment this to test the function after implementing it
-            // assert(result.size() == expected_result.size());
-            // for(int i = 0; i < result.size(); i++){
-            //     assert(result.get(i) == expected_result.get(i));
-            // }
+            assert(result.size() == expected_result.size());
+            for(int i = 0; i < result.size(); i++){
+                assert(result.get(i).equals(expected_result.get(i)));
+            }
 
             calciteConnection.close();
             
diff --git a/in/ac/iitd/src/test/java/manager/DeserializeTest.java b/in/ac/iitd/src/test/java/manager/DeserializeTest.java
index 5024b88..7d66d08 100644
--- a/in/ac/iitd/src/test/java/manager/DeserializeTest.java
+++ b/in/ac/iitd/src/test/java/manager/DeserializeTest.java
@@ -20,13 +20,13 @@ public class DeserializeTest {
 
             // Uncomment this to test the function after implementing it
 
-            // assert(result.size() == 78);
+            assert(result.size() == 78);
 
-            // for(int i = 0; i < result.size(); i++){
-            //     assert(result.get(i).length == 4);
-            //     assert(result.get(i)[0] instanceof Integer);
-            //     assert(result.get(i)[0].equals(expected.get(i)));
-            // }
+            for(int i = 0; i < result.size(); i++){
+                assert(result.get(i).length == 4);
+                assert(result.get(i)[0] instanceof Integer);
+                assert(result.get(i)[0].equals(expected.get(i)));
+            }
 
             calciteConnection.close();
 
